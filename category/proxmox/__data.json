{"type":"data","nodes":[{"type":"data","data":[{"categories":1},[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],"design","ui","meta","life","work","portfolio","programming","software","macos","multiplatform","games","tools","photography","linux","windows","proxmox"],"uses":{},"slash":"always"},{"type":"data","data":[{"articles":1,"slug":12},[2],{"slug":3,"path":4,"code":5,"fm":6},"tools-proxmox-mem","/articles/tools-proxmox-mem","\u003Cscript context=\"module\">\n\texport const metadata = {\"title\":\"Tools: Proxmox Memory Info\",\"comments\":true,\"categories\":\"tools proxmox software\"};\n\tconst { title, comments, categories } = metadata;\n\u003C/script>\n\u003Cscript lang=\"ts\">\n    import { styleObjToStr } from \"$lib/Utils.js\";\n    import Textarea from \"$joeysvelte/Textarea.svelte\";\n    \n    let qmListStr = `\\\n      VMID NAME                 STATUS     MEM(MB)    BOOTDISK(GB) PID       \n       100 fdsa                 running    4608              32.00 2826770   \n       101 asdf                 running    8192              24.00 2828068   \n       103 vcxz                 running    6144             170.00 4083340   \n       106 zxcv                 running    512                0.00 2829680   \n       107 rewq                 running    512                8.00 2828256   \n       108 qwer                 running    10240            280.00 2828390   \n       116 poiu                 stopped    1024              16.00 0         \n       119 uiop                 running    2048              16.00 2828601   \n`;\n    let pctListStr = `\\\ncpus: 4\ndisk: 8607637504\ndiskread: 5604175872\ndiskwrite: 5664735232\nmaxdisk: 16729894912\nmaxmem: 1610612736\nmaxswap: 268435456\nmem: 103804928\nname: zaq\nnetin: 1609895403\nnetout: 321521108\npid: 2819704\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486378\nvmid: 102\n===\ncpus: 2\ndisk: 2569617408\ndiskread: 2268246016\ndiskwrite: 1185574912\nmaxdisk: 8350298112\nmaxmem: 2147483648\nmaxswap: 536870912\nmem: 446955520\nname: qaz\nnetin: 203442269\nnetout: 103766012\npid: 2819932\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486377\nvmid: 104\n===\ncpus: 2\ndisk: 14933626880\ndiskread: 50094080\ndiskwrite: 0\nmaxdisk: 33501757440\nmaxmem: 3221225472\nmaxswap: 536870912\nmem: 809078784\nname: xsw\nnetin: 1082231849\nnetout: 490525835\npid: 2820482\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486376\nvmid: 105\n===\ncpus: 1\ndisk: 1718788096\ndiskread: 8668491776\ndiskwrite: 4616585216\nmaxdisk: 8350298112\nmaxmem: 268435456\nmaxswap: 134217728\nmem: 125739008\nname: wsx\nnetin: 1890712714\nnetout: 260634596\npid: 2820755\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486375\nvmid: 109\n===\ncpus: 4\ndisk: 2408054784\ndiskread: 597217280\ndiskwrite: 0\nmaxdisk: 25769803776\nmaxmem: 4294967296\nmaxswap: 536870912\nmem: 2604072960\nname: cde\nnetin: 128455070\nnetout: 90778783\npid: 2817017\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486459\nvmid: 110\n===\ncpus: 1\ndisk: 2349285376\ndiskread: 15766028288\ndiskwrite: 28394274816\nmaxdisk: 8350298112\nmaxmem: 805306368\nmaxswap: 268435456\nmem: 40759296\nname: edc\nnetin: 1229295854\nnetout: 1045237055\npid: 2821383\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486373\nvmid: 111\n===\ncpus: 1\ndisk: 5181554688\ndiskread: 28819456\ndiskwrite: 0\nmaxdisk: 8350298112\nmaxmem: 402653184\nmaxswap: 134217728\nmem: 136101888\nname: vfr\nnetin: 120298060\nnetout: 1821795\npid: 2821938\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486373\nvmid: 112\n===\ncpus: 1\ndisk: 1094844416\ndiskread: 3101143040\ndiskwrite: 527785984\nmaxdisk: 8350298112\nmaxmem: 201326592\nmaxswap: 134217728\nmem: 33763328\nname: rfv\nnetin: 154376120\nnetout: 1976845\npid: 2822212\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486373\nvmid: 113\n===\ncpus: 4\ndisk: 6096498688\ndiskread: 8319344640\ndiskwrite: 6460186624\nmaxdisk: 16729894912\nmaxmem: 1610612736\nmaxswap: 536870912\nmem: 262180864\nname: bgt\nnetin: 107645972018\nnetout: 7305682389\npid: 2822414\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486372\nvmid: 114\n===\ncpus: 1\ndisk: 1116786688\ndiskread: 5317419008\ndiskwrite: 969625600\nmaxdisk: 8350298112\nmaxmem: 134217728\nmaxswap: 134217728\nmem: 32182272\nname: tgb\nnetin: 27261214\nnetout: 3653634\npid: 2822936\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486372\nvmid: 115\n===\ncpus: 1\ndisk: 0\ndiskread: 0\ndiskwrite: 0\nmaxdisk: 8589934592\nmaxmem: 268435456\nmaxswap: 134217728\nmem: 0\nname: nhy\nnetin: 0\nnetout: 0\nstatus: stopped\nswap: 0\ntype: lxc\nuptime: 0\nvmid: 117\n===\ncpus: 1\ndisk: 1221087232\ndiskread: 1466032128\ndiskwrite: 630587392\nmaxdisk: 16729894912\nmaxmem: 536870912\nmaxswap: 134217728\nmem: 169148416\nname: yhn\nnetin: 156576103\nnetout: 5348044\npid: 2825177\nstatus: running\nswap: 0\ntype: lxc\nuptime: 486353\nvmid: 118\n===\ncpus: 2\ndisk: 0\ndiskread: 0\ndiskwrite: 0\nmaxdisk: 17179869184\nmaxmem: 2147483648\nmaxswap: 536870912\nmem: 0\nname: mju\nnetin: 0\nnetout: 0\nstatus: stopped\nswap: 0\ntype: lxc\nuptime: 0\nvmid: 121\n===\n`;;\n    let meminfoStr = `\\\nMemTotal:       48588200 kB\nMemFree:         2121064 kB\nMemAvailable:    5148580 kB\nBuffers:          165496 kB\nCached:          3197324 kB\nSwapCached:            0 kB\nActive:         14693372 kB\nInactive:       26106296 kB\nActive(anon):   13714084 kB\nInactive(anon): 23904072 kB\nActive(file):     979288 kB\nInactive(file):  2202224 kB\nUnevictable:           0 kB\nMlocked:               0 kB\nSwapTotal:             0 kB\nSwapFree:              0 kB\nZswap:                 0 kB\nZswapped:              0 kB\nDirty:               396 kB\nWriteback:             0 kB\nAnonPages:      37436860 kB\nMapped:           924520 kB\nShmem:            183060 kB\nKReclaimable:     435548 kB\nSlab:            1441200 kB\nSReclaimable:     435548 kB\nSUnreclaim:      1005652 kB\nKernelStack:       21552 kB\nPageTables:       124804 kB\nSecPageTables:     11676 kB\nNFS_Unstable:          0 kB\nBounce:                0 kB\nWritebackTmp:          0 kB\nCommitLimit:    24294100 kB\nCommitted_AS:   46479152 kB\nVmallocTotal:   34359738367 kB\nVmallocUsed:      823808 kB\nVmallocChunk:          0 kB\nPercpu:            73984 kB\nHardwareCorrupted:     0 kB\nAnonHugePages:  26798080 kB\nShmemHugePages:        0 kB\nShmemPmdMapped:        0 kB\nFileHugePages:         0 kB\nFilePmdMapped:         0 kB\nUnaccepted:            0 kB\nHugePages_Total:       0\nHugePages_Free:        0\nHugePages_Rsvd:        0\nHugePages_Surp:        0\nHugepagesize:       2048 kB\nHugetlb:               0 kB\nDirectMap4k:      595876 kB\nDirectMap2M:    15441920 kB\nDirectMap1G:    34603008 kB\n`;\n\nfunction keyColonValueToRecord(str: string) {\n    return str.split('\\n').reduce((acc, line) => {\n        const [key, value] = line.split(':').map(s => s.trim());\n        if (!key) return acc;\n        try {\n            acc[key] = parseFloat(value);\n            if (isNaN(acc[key])) throw new Error('Not a number');\n            if (acc[key].toString() != value) {\n                throw new Error('Does not look like a number');\n            }\n        } catch (e) {\n            acc[key] = value;\n        }\n        return acc;\n    }, {} as Record\u003Cstring, any>);\n}\n\nfunction spaceDelimitedTableToRecordList(str: string) {\n    const lines = str.split('\\n').map(s => s.trim()).filter(s => s.length > 0);\n    const headers = lines[0].split(/\\s+/);\n    return lines.slice(1).map(line => {\n        const values = line.split(/\\s+/);\n        return headers.reduce((acc, header, i) => {\n            acc[header] = values[i];\n            return acc;\n        }, {} as Record\u003Cstring, string | number>);\n    });\n}\n\nfunction parseQmListStr(qmListStr: string) {\n    let data = spaceDelimitedTableToRecordList(qmListStr);\n    \n    let outRecord = {};\n        \n    data.forEach(item => {\n        const key = item['VMID'];\n        delete item['VMID'];\n        item['MEM'] = parseFloat(item['MEM(MB)'] as string) * 1024 * 1024;\n        delete item['MEM(MB)'];\n        item['BOOTDISK'] = parseFloat(item['BOOTDISK(GB)'] as string) * 1024 * 1024 * 1024;\n        delete item['BOOTDISK(GB)'];\n        outRecord[key] = item;\n    });\n    \n    return outRecord;\n}\n\nfunction parsePctListStr(pctListStr: string) {\n    const splitByContainer = (\n        pctListStr.split('===')\n            .map(s => s.trim())\n            .filter(s => s.length > 0)\n    );\n    \n    let outRecord = {};\n        \n    splitByContainer.forEach(containerStr => {\n        let data = keyColonValueToRecord(containerStr);\n        const key = data['vmid'];\n        delete data['vmid'];\n        outRecord[key] = data;\n    });\n    \n    return outRecord;\n}\n\nfunction parseMeminfoStr(meminfoStr: string) {\n    let data = keyColonValueToRecord(meminfoStr);\n    for (const key in data) {\n        const value = data[key];\n        if (typeof value == 'string') {\n            if (value.endsWith(' kB')) {\n                data[key] = parseInt(value.slice(0, -3)) * 1024;\n            } else if (value.endsWith(' MB')) {\n                data[key] = parseInt(value.slice(0, -3)) * 1024 * 1024;\n            } else {\n                data[key] = parseInt(value);\n            }\n        } else {\n            data[key] = value;\n        }\n    }\n    return data;\n}\n\nfunction bytesToGBStr(bytes: number) {\n    let gb = bytes / 1024 / 1024 / 1024;\n    return gb.toFixed(2) + \" GB\";\n}\n\nlet qmRecord: Record\u003Cstring, Record\u003Cstring, string | number>>;\nlet pctRecord: Record\u003Cstring, Record\u003Cstring, string | number>>;\nlet meminfoRecord: Record\u003Cstring, string | number>;\n\n$: qmRecord = parseQmListStr(qmListStr);\n$: pctRecord = parsePctListStr(pctListStr);\n$: meminfoRecord = parseMeminfoStr(meminfoStr);\n\nfunction sumArr(arr: number[]) {\n    return arr.reduce((acc, val) => acc + val, 0);\n}\n\nlet currentItemMemTotal: number;\n$: currentItemMemTotal = (\n    sumArr(Object.values(pctRecord).map(data => data.mem as number))\n    + sumArr(Object.values(qmRecord).map(data => (\n        data.STATUS == 'running'\n        ? data.MEM as number\n        : 0\n    )))\n);\n\nlet maxItemMemTotal: number;\n$: maxItemMemTotal = (\n    sumArr(Object.values(pctRecord).map(data => data.maxmem as number))\n    + sumArr(Object.values(qmRecord).map(data => data.MEM as number))\n);\n\nlet currentSystemMem: number;\n$: currentSystemMem = (\n    (meminfoRecord.MemTotal as number)\n    - (meminfoRecord.MemAvailable as number)\n);\n\nlet hostMemUsed: number;\n$: hostMemUsed = currentSystemMem - currentItemMemTotal;\n\nlet maxMemUse: number;\n$: maxMemUse = hostMemUsed + maxItemMemTotal;\n\nlet memAvailableForProvisioning: number;\n$: memAvailableForProvisioning = (meminfoRecord.MemTotal as number) - maxMemUse;\n\n\u003C/script>\n\n\n\u003Cp>Proxmox doesn’t have a built-in way to check if you’re overcommitting memory on your host. (That I know of?) This is a simple tool that gives you a summary of your memory usage using some shell commands and copypasta.\u003C/p>\n\u003Ch2>Paste the output of…\u003C/h2>\n\u003Cpre class=\"language-bash\">{@html `\u003Ccode class=\"language-bash\">qm list\u003C/code>`}\u003C/pre>\n\u003Cp>down here:\u003C/p>\n\u003CTextarea wrap={false} bind:value={qmListStr} />\n\u003Ch2>Paste the output of…\u003C/h2>\n\u003Cpre class=\"language-bash\">{@html `\u003Ccode class=\"language-bash\">pct list \u003Cspan class=\"token operator\">|\u003C/span> \u003Cspan class=\"token function\">grep\u003C/span> \u003Cspan class=\"token parameter variable\">-v\u003C/span> VMID \u003Cspan class=\"token operator\">|\u003C/span> \u003Cspan class=\"token function\">awk\u003C/span> \u003Cspan class=\"token string\">'&#123;'\u003C/span>\u003Cspan class=\"token punctuation\">&#123;\u003C/span>\u003Cspan class=\"token string\">'&#125; print $1 &#123;'\u003C/span>\u003Cspan class=\"token punctuation\">&#125;\u003C/span>\u003Cspan class=\"token string\">'&#125;'\u003C/span> \u003Cspan class=\"token operator\">|\u003C/span> \u003Cspan class=\"token function\">xargs\u003C/span> \u003Cspan class=\"token parameter variable\">-I\u003C/span> x \u003Cspan class=\"token function\">sh\u003C/span> \u003Cspan class=\"token parameter variable\">-c\u003C/span> \u003Cspan class=\"token string\">'pct status x -verbose &amp;&amp; echo ==='\u003C/span>\u003C/code>`}\u003C/pre>\n\u003Cp>down here:\u003C/p>\n\u003CTextarea wrap={false} bind:value={pctListStr} />\n\u003Ch2>Paste the output of…\u003C/h2>\n\u003Cpre class=\"language-bash\">{@html `\u003Ccode class=\"language-bash\">\u003Cspan class=\"token function\">cat\u003C/span> /proc/meminfo\u003C/code>`}\u003C/pre>\n\u003Cp>down here:\u003C/p>\n\u003CTextarea wrap={false} bind:value={meminfoStr} />\n\u003Ch2>Results\u003C/h2>\n\u003Ctable>\n    \u003Cthead>\n        \u003Ctr>\n            \u003Cth>\u003C/th>\n            \u003Cth>VM ID\u003C/th>\n            \u003Cth>Name\u003C/th>\n            \u003Cth>Type\u003C/th>\n            \u003Cth>Status\u003C/th>\n            \u003Cth style=\"text-align:right\">Current Mem.\u003C/th>\n            \u003Cth style=\"text-align:right\">Max Mem.\u003C/th>\n        \u003C/tr>\n    \u003C/thead>\n    \u003Ctbody>\n        {#each Object.entries(pctRecord) as [vmid, data]}\n            \u003Ctr>\n                \u003Ctd>\u003C/td>\n                \u003Ctd>{vmid}\u003C/td>\n                \u003Ctd>{data.name}\u003C/td>\n                \u003Ctd>{data.type}\u003C/td>\n                \u003Ctd>{data.status}\u003C/td>\n                \u003Ctd style=\"text-align:right\">{bytesToGBStr(data.mem as number)}\u003C/td>\n                \u003Ctd style=\"text-align:right\">{bytesToGBStr(data.maxmem as number)}\u003C/td>\n            \u003C/tr>\n        {/each}\n        {#each Object.entries(qmRecord) as [vmid, data]}\n            \u003Ctr>\n                \u003Ctd>\u003C/td>\n                \u003Ctd>{vmid}\u003C/td>\n                \u003Ctd>{data.NAME}\u003C/td>\n                \u003Ctd>qemu\u003C/td>\n                \u003Ctd>{data.STATUS}\u003C/td>\n                \u003Ctd style=\"text-align:right\">{data.STATUS == \"running\" ? bytesToGBStr(data.MEM as number) : 0}\u003C/td>\n                \u003Ctd style=\"text-align:right\">{bytesToGBStr(data.MEM as number)}\u003C/td>\n            \u003C/tr>\n        {/each}\n        \u003Ctr>\n            \u003Ctd>\u003Cb>Totals\u003C/b>\u003C/td>\n            \u003Ctd>\u003C/td>\n            \u003Ctd>\u003C/td>\n            \u003Ctd>\u003C/td>\n            \u003Ctd>\u003C/td>\n            \u003Ctd style=\"text-align:right\">\n                \u003Cb>{bytesToGBStr(currentItemMemTotal)}\u003C/b>\n            \u003C/td>\n            \u003Ctd style=\"text-align:right\">\n                \u003Cb>{bytesToGBStr(maxItemMemTotal)}\u003C/b>\n            \u003C/td>\n        \u003C/tr>\n\u003C/table>\n\u003Ctable>\n    \u003Ctbody>\n        \u003Ctr>\n            \u003Cth>Current System Memory Usage\u003C/th>\n            \u003Ctd>{bytesToGBStr(currentSystemMem)}\u003C/td>\n        \u003C/tr>\n        \u003Ctr>\n            \u003Cth>Memory Used by Host\u003C/th>\n            \u003Ctd>{bytesToGBStr(hostMemUsed)}\u003C/td>\n        \u003C/tr>\n        \u003Ctr>\n            \u003Cth>Max Potential Memory Use\u003C/th>\n            \u003Ctd>{bytesToGBStr(maxMemUse)}\u003C/td>\n        \u003C/tr>\n        \u003Ctr>\n            \u003Cth>Total Host Memory\u003C/th>\n            \u003Ctd>{bytesToGBStr(meminfoRecord.MemTotal as number)}\u003C/td>\n        \u003C/tr>\n        \u003Ctr>\n            \u003Cth>Available for Provisioning\u003C/th>\n             \u003Ctd\n                style={styleObjToStr({\n                    color: (\n                        memAvailableForProvisioning > 0\n                        ? \"green\"\n                        : \"hotpink\"\n                    )\n                })}\n            >\n                {bytesToGBStr(memAvailableForProvisioning)}\n        \u003C/td>\n        \u003C/tr>\n    \u003C/tbody>\n\u003C/table>\n",{"title":7,"comments":8,"categories":9,"last_modified_at":10,"date":11},"Tools: Proxmox Memory Info",true,"tools proxmox software","2025-07-21T22:15:21-04:00","2025-04-07T13:57:11-04:00","proxmox"],"uses":{"params":["slug"]}}]}
